# R Script to Parse Binary IMU Data from the Tudor Slave Unit
#
# This script reads the custom binary format created by the Teensy-based
# data logger. It first parses a 32-byte file header, then iteratively
# reads data chunks until the end of the file is reached.
#
# The binary file structure is as follows:
# 1. File Header (32 bytes, once at the start of the file)
# 2. Data Chunks (repeated until EOF)
#    - Chunk Header (8 bytes)
#    - IMU Raw Data (variable size, based on chunk header)

# install.packages("dplyr") # Uncomment to install dplyr if you don't have it
library(dplyr)

#' @title Parse Tudor IMU Binary File
#' @description Reads and parses the binary data file generated by the IMU data logger.
#' @param filepath The full path to the .bin file.
#' @return A single data frame (tibble) containing the parsed data with columns:
#'         `chunk_timestamp_ms`, `interpolated_time_s`, `accel_x`, `accel_y`, `accel_z`.
#'         Returns NULL if the file is invalid or cannot be read.
parse_imu_file <- function(filepath) {
  
  # Check if the file exists before proceeding
  if (!file.exists(filepath)) {
    stop("Error: File not found at the specified path: ", filepath)
  }
  
  # Open the file in binary read mode ("rb")
  con <- file(filepath, "rb")
  on.exit(close(con)) # Ensure the file connection is closed, even if errors occur
  
  # --- 1. Read the 32-byte File Header ---
  # The endianness must be set to "little" as the Teensy microcontroller is little-endian.
  header <- list(
    file_type = rawToChar(readBin(con, "raw", n = 4)),
    version = readBin(con, "integer", n = 1, size = 2, signed = FALSE, endian = "little"),
    sample_rate_hz = readBin(con, "integer", n = 1, size = 2, signed = FALSE, endian = "little"),
    fifo_size_samples = readBin(con, "integer", n = 1, size = 2, signed = FALSE, endian = "little"),
    unit_number = readBin(con, "integer", n = 1, size = 2, signed = FALSE, endian = "little")
  )
  # Skip the 20 reserved bytes
  readBin(con, "raw", n = 20)
  
  # --- 2. Print Header Info and Validate ---
  cat("--- File Header ---\n")
  cat("File Type:        ", header$file_type, "\n")
  cat("Format Version:   ", header$version, "\n")
  cat("Sample Rate (Hz): ", header$sample_rate_hz, "\n")
  cat("FIFO Size:        ", header$fifo_size_samples, "\n")
  cat("Unit Number:      ", header$unit_number, "\n")
  cat("-------------------\n\n")
  
  # Stop if the file type or version is not what we expect
  if (header$file_type != "IMU") {
    stop("Error: Invalid file type. Expected 'IMU'.")
  }
  if (header$version != 2) {
    warning("Warning: File version is not 2. The parser may not work correctly.")
  }
  
  # --- 3. Read Data Chunks Iteratively ---
  all_chunks <- list()
  
  # Loop until we can't read a full chunk header, which indicates end-of-file
  while (TRUE) {
    # Read the 8-byte chunk header
    chunk_header_raw <- readBin(con, "raw", n = 8)
    
    # If we read less than 8 bytes, we've hit the end of the file
    if (length(chunk_header_raw) < 8) {
      break
    }
    
    # Create a temporary connection to the raw vector to parse it
    chunk_con <- rawConnection(chunk_header_raw)
    
    chunk_timestamp_ms <- readBin(chunk_con, "integer", n = 1, size = 4, signed = FALSE, endian = "little")
    num_samples <- readBin(chunk_con, "integer", n = 1, size = 2, signed = FALSE, endian = "little")
    # The final 2 bytes are reserved and can be ignored
    close(chunk_con)
    
    if (num_samples == 0) {
      next # Skip empty chunks if they ever occur
    }
    
    # Calculate the total number of 16-bit integers to read for this chunk's data
    # (3 axes per sample)
    num_values_to_read <- num_samples * 3
    
    # Read the raw accelerometer data (signed 16-bit integers)
    imu_data_raw <- readBin(con, "integer", n = num_values_to_read, size = 2, signed = TRUE, endian = "little")
    
    # Convert the raw vector into a 3-column matrix
    imu_matrix <- matrix(imu_data_raw, ncol = 3, byrow = TRUE)
    
    # Calculate the time interval between individual samples in seconds
    time_per_sample_s <- 1.0 / header$sample_rate_hz
    
    # Create a sequence of interpolated timestamps for each sample within the chunk
    interpolated_times <- chunk_timestamp_ms / 1000 + (seq(0, num_samples - 1) * time_per_sample_s)
    
    # Store the parsed data for this chunk in the list
    all_chunks[[length(all_chunks) + 1]] <- tibble(
      chunk_timestamp_ms = chunk_timestamp_ms,
      interpolated_time_s = interpolated_times,
      accel_x = imu_matrix[, 1],
      accel_y = imu_matrix[, 2],
      accel_z = imu_matrix[, 3]
    )
  }
  
  cat("Successfully parsed", length(all_chunks), "data chunks.\n")
  
  # Combine the list of tibbles into a single, large tibble
  final_data <- bind_rows(all_chunks)
  
  return(final_data)
}


# --- EXAMPLE USAGE ---

# Use file.choose() to open a file browser and select your .bin file interactively
# filepath <- file.choose()

# Or, you can hardcode the path to your file for non-interactive use
# Make sure to use forward slashes "/" or double backslashes "\\" in the path.
filepath <- file.choose()

if(file.exists(filepath)) {
  # Call the parsing function
  imu_df <- parse_imu_file(filepath)
  
  # Display the structure and the first few rows of the resulting data frame
  cat("\n--- Parsed Data Summary ---\n")
  str(imu_df)
  cat("\n")
  print(head(imu_df))
  cat("\n")
  print(tail(imu_df))
  
  # Optional: Create a simple plot of the X-axis acceleration
  # install.packages("ggplot2") # Uncomment if you need to install it
  # library(ggplot2)
  # ggplot(imu_df, aes(x = interpolated_time_s, y = accel_x)) +
  #   geom_line() +
  #   labs(
  #     title = "X-Axis Acceleration vs. Time",
  #     x = "Time (s)",
  #     y = "Raw Accelerometer Reading"
  #   ) +
  #   theme_minimal()
  
} else {
  cat("File '", filepath, "' not found. Please update the filepath variable.\n", sep="")
}
