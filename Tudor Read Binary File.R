# R Script to Parse Binary Data from Teensy Data Logger
#
# This script reads the custom binary format generated by the C++ code
# in the 'arduino_logger_revised_gps' artifact.

# Required libraries (install if you don't have them)
# install.packages("tidyverse") # Optional, but recommended for data manipulation
library(tidyverse)
library(plotly)
library(ggplot2)

# --- Main Parsing Function ---

# Prompt user to select the binary file
file_path <- file.choose()

{
  if (!file.exists(file_path)) {
  stop("File not found.")
}

# Open the file for reading in binary mode
con <- file(file_path, "rb")

# Create a list to hold the parsed records
records_list <- list()

# Loop until the end of the file is reached
while (TRUE) {
  
  # 1. Read the first field to check if we're at the end of the file
  index <- readBin(con, integer(), n = 1, size = 4)
  if (length(index) == 0) {
    break # End of file
  }
  
  # 2. Read all other fixed-size fields up to the variable-length arrays
  cadenceTime <- readBin(con, integer(), n = 1, size = 4)
  positionDeg <- readBin(con, integer(), n = 1, size = 4)
  DegSamples <- readBin(con, integer(), n = 1, size = 4)
  
  # 3. Read the DegTimeArray based on the value of hzSamples
  # Use max(0, hzSamples) to prevent errors if hzSamples is negative or invalid
  DegTimeArray <- list(readBin(con, integer(), n = max(0, 6), size = 4))
  DegSumTime <- sum(unlist(DegTimeArray))
  
  # 4. Read the fields between the two variable arrays
  numSat <- readBin(con, integer(), n = 1, size = 1, signed = FALSE)
  epochTime_s <- readBin(con, integer(), n = 1, size = 4, signed = FALSE)
  epochTime_ms <- readBin(con, integer(), n = 1, size = 4, signed = FALSE)
  groundSpeed <- readBin(con, integer(), n = 1, size = 4, signed = TRUE)
  speed_accuracy <- readBin(con, integer(), n = 1, size = 4, signed = TRUE)
  altitute <- readBin(con, integer(), n = 1, size = 4, signed = TRUE)
  latitude <- readBin(con, integer(), n = 1, size = 4, signed = TRUE)
  longitude <- readBin(con, integer(), n = 1, size = 4, signed = TRUE)
  power <- readBin(con, integer(), n = 1, size = 2, signed = FALSE)
  cadence <- readBin(con, integer(), n = 1, size = 1, signed = FALSE)
  
  # 5. Read the count for the torque values
  torqueValueCount <- readBin(con, integer(), n = 1, size = 1, signed = FALSE)
  
  # 6. Read the torqueValues array based on the value of torqueValueCount
  torqueValues <- list(readBin(con, integer(), n = max(0, torqueValueCount), size = 2, signed = TRUE))
  
  # 7. Assemble the full record and add it to our list
  record <- list(
    index = index,
    wheelTime = cadenceTime,
    DegSumTime = DegSumTime,
    positionDeg = positionDeg,
    DegSamples = DegSamples,
    DegTimeArray = DegTimeArray,
    numSat = numSat,
    epochTime_s = epochTime_s,
    epochTime_ms = epochTime_ms,
    groundSpeed = groundSpeed,
    speed_accuracy = speed_accuracy,
    altitute = altitute,
    latitude = latitude,
    longitude = longitude,
    power = power,
    cadence = cadence,
    torqueValueCount = torqueValueCount,
    torqueValues = torqueValues
  )
  
  records_list[[length(records_list) + 1]] <- record
}

# Close the file connection
close(con)

# Use bind_rows to create the final tibble
if(length(records_list) > 0) {
  log_data <- bind_rows(records_list)
}
}


#write.table(apply(log_data,2,as.character), file="clipboard-16384", sep="\t", row.names=FALSE, col.names=T)


# --- Data Correction: Fix Split Revolutions ---
SAMPLES_PER_REV <- 6
# Create an empty list to store the corrected records
{
corrected_records <- list()
i <- 1 # Initialize a counter for the while loop

cat("--- Starting data correction process... ---\n")
original_rows <- nrow(log_data)

while (i <= original_rows) {
  # Get the current row
  current_row <- log_data[i, ]
  
  # Check if the revolution might be split AND that we are not at the last row
  if (current_row$DegSamples < SAMPLES_PER_REV && i < original_rows) {
    next_row <- log_data[i + 1, ]
    
    # Check if this row and the next one form a complete 18-sample revolution
    is_valid_split <- (current_row$DegSamples + next_row$DegSamples == SAMPLES_PER_REV)
    
    if (is_valid_split) {
      # --- Merge the two rows ---
      merged_row <- current_row # Start with the first row as a template
      
      # Combine the time arrays from both rows
      merged_row$DegTimeArray <- list(c(unlist(current_row$DegTimeArray), unlist(next_row$DegTimeArray)))
      merged_row$torqueValues <- list(c(unlist(current_row$torqueValues), unlist(next_row$torqueValues)))

      
      # Update the sample counts
      merged_row$DegSamples <- SAMPLES_PER_REV
      
      # Recalculate the SumTime for the newly combined arrays
      merged_row$DegSumTime <- sum(unlist(merged_row$DegTimeArray))
      
      # Add the single merged row to our corrected list
      corrected_records[[length(corrected_records) + 1]] <- merged_row
      
      # IMPORTANT: Skip the next row since we've already processed it
      i <- i + 2 
      next # Continue to the next iteration of the loop
    }
  }
  
  # If the row is complete (or is a short row we can't fix), add it as is
  # We can choose to keep or discard incomplete rows that couldn't be merged
  if (current_row$DegSamples == SAMPLES_PER_REV) {
    corrected_records[[length(corrected_records) + 1]] <- current_row
  }
  
  # Move to the next row
  i <- i + 1
}

# Combine the list of corrected records into a final, clean tibble
corrected_log_data <- bind_rows(corrected_records)

cat("Data correction complete.\n")
cat("Original number of rows:", original_rows, "\n")
cat("Corrected number of rows:", nrow(corrected_log_data), "\n\n")


# --- Verification ---
cat("--- Sample Counts Before Correction ---\n")
print(table(log_data$DegSamples))

cat("\n--- Sample Counts After Correction ---\n")
# This table should now ideally only show '18'
print(table(corrected_log_data$DegSamples))
}


write.table(apply(corrected_log_data,2,as.character), file="clipboard-16384", sep="\t", row.names=FALSE, col.names=T)

log_data$DegTimeArray[489]

library(ggplot2)

# Assuming 'log_data' is your tibble created from the binary file.

# --- Plot for DegTimeArray ---

# 1. Prepare the data: unnest and filter
deg_time_data <- corrected_log_data %>%
  select(DegTimeArray) %>%
  unnest(cols = c(DegTimeArray)) %>%
  filter(DegTimeArray != 0) %>%
  mutate(data_point_index = row_number())

# 2. Create the plot
deg_time_plot <- ggplot(deg_time_data, aes(x = data_point_index, y = DegTimeArray)) +
  geom_line(color = "blue") +
  labs(
    title = "Continuous Plot of DegTimeArray (Zeros Removed)",
    x = "Data Point Index",
    y = "DegTimeArray Value"
  ) +
  theme_minimal()

# 3. Display the plot
print(deg_time_plot)


# --- Plot for torqueValues ---

# 1. Prepare the data: unnest
torque_data <- corrected_log_data %>%
  select(torqueValues) %>%
  unnest(cols = c(torqueValues)) %>%
  mutate(data_point_index = row_number())

# 2. Create the plot
torque_plot <- ggplot(torque_data, aes(x = data_point_index, y = torqueValues)) +
  geom_line(color = "red") +
  labs(
    title = "Continuous Plot of Torque Values",
    x = "Data Point Index",
    y = "Torque Value"
  ) +
  theme_minimal()

# 3. Display the plot
print(torque_plot)


# --- 1. Prepare Torque Data ---
# Unnest the torque values and create a time axis based on a 60Hz sampling rate.
torque_plot_data <- corrected_log_data %>%
  select(torqueValues) %>%
  unnest(cols = c(torqueValues)) %>%
  mutate(
    time_sec = (row_number() - 1) / 60, # Time in seconds (sample_index / sample_rate)
    measurement = "Torque"
  ) %>%
  rename(value = torqueValues)

# --- 2. Prepare DegTimeArray Data ---
# Unnest, filter zeros, and create a cumulative time axis in seconds.
deg_time_plot_data <- corrected_log_data %>%
  select(DegTimeArray) %>%
  unnest(cols = c(DegTimeArray)) %>%
  filter(DegTimeArray != 0) %>%
  mutate(
    # Convert microseconds to seconds and then calculate the cumulative sum
    time_sec = cumsum(as.numeric(DegTimeArray) / 1000000),
    measurement = "DegTime"
  ) %>%
  rename(value = DegTimeArray)

# This code builds on the 'torque_plot_data' and 'deg_time_plot_data'
# data frames created in Method 1.

# --- 1. Determine Scaling Factor ---
# We will scale the DegTime values to fit within the range of the Torque values.
torque_range <- range(torque_plot_data$value, na.rm = TRUE)
deg_time_range <- range(deg_time_plot_data$value, na.rm = TRUE)

# --- 2. Create the Plot with a Secondary Axis ---
# The trick is to manually scale the second data source and then add a
# secondary axis that reverses the scaling transformation for its labels.
p <- ggplot() +
  # Plot the first series (Torque)
  geom_line(
    data = torque_plot_data,
    aes(x = time_sec, y = value, color = "Torque")
  ) +
  # Plot the second, scaled series (DegTime)
  geom_line(
    data = deg_time_plot_data,
    # Scale 'value' from its original range to the torque range
    aes(
      x = time_sec,
      y = (value - deg_time_range[1]) / diff(deg_time_range) * diff(torque_range) + torque_range[1],
      color = "DegTime"
    )
  ) +
  # Add the secondary Y-axis
  scale_y_continuous(
    name = "Torque Value",
    # Add the secondary axis, reversing the transformation
    sec.axis = sec_axis(
      trans = ~ (. - torque_range[1]) / diff(torque_range) * diff(deg_time_range) + deg_time_range[1],
      name = "DegTimeArray Value"
    )
  ) +
  # --- 3. Add Labels and Formatting ---
  labs(
    title = "Torque and DegTimeArray with Dual Y-Axes",
    x = "Time (seconds)",
    color = "Measurement"
  ) +
  theme_minimal() +
  scale_color_manual(values = c("Torque" = "red", "DegTime" = "blue")) +
  theme(
    axis.title.y.left = element_text(color = "red"),
    axis.text.y.left = element_text(color = "red"),
    axis.title.y.right = element_text(color = "blue"),
    axis.text.y.right = element_text(color = "blue")
  )

ggplotly(p)
