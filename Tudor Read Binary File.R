# R Script to Parse Binary Data from Teensy Data Logger
#
# This script reads the custom binary format generated by the C++ code
# in the 'arduino_logger_revised_gps' artifact.

# Required libraries (install if you don't have them)
# install.packages("tidyverse") # Optional, but recommended for data manipulation
library(tidyverse)

# --- Main Parsing Function ---

# Prompt user to select the binary file
file_path <- file.choose()

{
  if (!file.exists(file_path)) {
  stop("File not found.")
}

# Open the file for reading in binary mode
con <- file(file_path, "rb")

# Create a list to hold the parsed records
records_list <- list()

# Loop until the end of the file is reached
while (TRUE) {
  
  # 1. Read the first field to check if we're at the end of the file
  index <- readBin(con, integer(), n = 1, size = 4, signed = FALSE)
  if (length(index) == 0) {
    break # End of file
  }
  
  # 2. Read all other fixed-size fields up to the variable-length arrays
  cadenceTime <- readBin(con, integer(), n = 1, size = 4, signed = FALSE)
  positionDeg <- readBin(con, integer(), n = 1, size = 4, signed = FALSE)
  DegSamples <- readBin(con, integer(), n = 1, size = 4, signed = FALSE)
  
  # 3. Read the DegTimeArray based on the value of hzSamples
  # Use max(0, hzSamples) to prevent errors if hzSamples is negative or invalid
  DegTimeArray <- list(readBin(con, integer(), n = max(0, 18), size = 2, signed = FALSE))
  
  # 4. Read the fields between the two variable arrays
  numSat <- list(readBin(con, integer(), n = 1, size = 1, signed = FALSE))
  epochTime_s <- readBin(con, integer(), n = 1, size = 4, signed = FALSE)
  epochTime_ms <- readBin(con, integer(), n = 1, size = 4, signed = FALSE)
  groundSpeed <- readBin(con, integer(), n = 1, size = 4, signed = TRUE)
  speed_accuracy <- readBin(con, integer(), n = 1, size = 4, signed = TRUE)
  altitute <- readBin(con, integer(), n = 1, size = 4, signed = TRUE)
  latitude <- readBin(con, integer(), n = 1, size = 4, signed = TRUE)
  longitude <- readBin(con, integer(), n = 1, size = 4, signed = TRUE)
  power <- readBin(con, integer(), n = 1, size = 2, signed = FALSE)
  cadence <- readBin(con, integer(), n = 1, size = 1, signed = FALSE)
  
  # 5. Read the count for the torque values
  torqueValueCount <- readBin(con, integer(), n = 1, size = 1, signed = FALSE)
  
  # 6. Read the torqueValues array based on the value of torqueValueCount
  torqueValues <- list(readBin(con, integer(), n = max(0, torqueValueCount), size = 2, signed = TRUE))
  
  # 7. Assemble the full record and add it to our list
  record <- list(
    index = index,
    cadenceTime = cadenceTime,
    positionDeg = positionDeg,
    DegSamples = DegSamples,
    DegTimeArray = DegTimeArray,
    numSat = numSat,
    epochTime_s = epochTime_s,
    epochTime_ms = epochTime_ms,
    groundSpeed = groundSpeed,
    speed_accuracy = speed_accuracy,
    altitute = altitute,
    latitude = latitude,
    longitude = longitude,
    power = power,
    cadence = cadence,
    torqueValueCount = torqueValueCount,
    torqueValues = torqueValues
  )
  
  records_list[[length(records_list) + 1]] <- record
}

# Close the file connection
close(con)

# Use bind_rows to create the final tibble
if(length(records_list) > 0) {
  log_data <- bind_rows(records_list)
}
}

log_data$torqueValues[1]

log_data %>% 
  mutate(Epoch = epochTime_s*100000 + epochTime_ms ) %>% 
  relocate(Epoch, .before="epochTime_s") %>% 
  view()

writeData <- log_data %>% 
  mutate(Epoch = epochTime_s*100000 + epochTime_ms, latitude = latitude/1E7, longitude = longitude/1E7, Speed_kmh = (groundSpeed/1000)*3.6) %>% 
  relocate(Epoch, .before="epochTime_s") %>% 
  select(-c(DegTimeArray, torqueValues)) %>% 
  as.data.frame()


write.table(apply(writeData,2,as.character), file="clipboard-16384", sep="\t", row.names=FALSE, col.names=T)

log_data$DegTimeArray[20]
# --- Post-Processing and Display ---

# Convert the Unix epoch timestamp to a human-readable POSIXct format
log_data <- log_data %>%
  mutate(
    timestamp_utc = as.POSIXct(epochTime_s, origin = "1970-01-01", tz = "UTC"),
    # Convert ground speed from mm/s to km/h for easier interpretation
    groundSpeed_kmh = groundSpeed * 0.0036
  ) %>% 
  view()

log_data %>% 
  slice (-1:-2) %>% 
  select(index, DegTimeArray) %>% 
  unnest(DegTimeArray) %>% 
  mutate(elapsed_s = cumsum(DegTimeArray)/1000000) %>% 
  view()

# Print the structure and head of the final data frame
cat("--- Data Parsing Complete ---\n\n")
cat("Structure of the final data frame:\n")
str(log_data)

cat("\n\nFirst 6 records:\n")
print(head(log_data))

cat("\n--- Notes on Usage ---\n")
cat("The data is now in the 'log_data' data frame.\n")
cat("The 'DegTimeArray' and 'torqueValues' columns are list-columns.\n")
cat("To analyze the data within these arrays, you can use 'tidyr::unnest()'.\n")
cat("Example: log_data %>% select(index, torqueValues) %>% unnest(torqueValues)\n")

